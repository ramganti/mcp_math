"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
var sdk_1 = require("../common/services/sdk");
var rxjs_1 = require("rxjs");
var const_1 = require("./const");
var change_country_1 = require("./change-country");
var rxjs_2 = require("rxjs");
var GV = require("../common/global_variables");
var utils_1 = require("./utils");
var synchronize_1 = require("./synchronize");
var multicalculate_1 = require("./multicalculate");
var global_variables_1 = require("../common/global_variables");
require('../assets/tingle.css');
var SdkConfig = /** @class */ (function () {
    function SdkConfig(settings) {
        this.settings = settings;
        /** @ToDo consultar si esto es correcto */
        this.apiConfig = this.setConfigAPI(settings.IS_API_BETA, settings.IS_API_PREPROD);
        this.settings.URL = this.apiConfig.SKYBOX_CHECKOUT_API + 'store/' + settings.IDSTORE + '/ipdata';
        this.settings.SKYBOX_URL = this.apiConfig.SKYBOX_CHECKOUT_URL;
    }
    /** @ToDo esta funcion se podria reducir, consultarlo */
    SdkConfig.prototype.setConfigAPI = function (isBeta, isPreProd) {
        var SKYBOX_CHECKOUT_URL = "https://www.skyboxcheckout.com/";
        var SKYBOX_CHECKOUT_API = "https://api.skyboxcheckout.com";
        var SKYBOX_CHECKOUT_URL_CONTENT = "https://api.skyboxcheckout.com";
        if (isPreProd) {
            SKYBOX_CHECKOUT_URL = "https://www.skyboxcheckout.com/PreApp/";
            SKYBOX_CHECKOUT_API = "https://www.skyboxcheckout.com/PreProdApiV2";
            SKYBOX_CHECKOUT_URL_CONTENT = "https://beta.skyboxcheckout.com/PreProdApiV2";
        }
        else if (isBeta) {
            SKYBOX_CHECKOUT_URL = "https://beta.skyboxcheckout.com/BetaApp/";
            SKYBOX_CHECKOUT_API = "https://www.skyboxcheckout.com/BetaApiV2";
            SKYBOX_CHECKOUT_URL_CONTENT = "https://beta.skyboxcheckout.com/BetaApiV2";
        }
        return {
            SKYBOX_CHECKOUT_URL: SKYBOX_CHECKOUT_URL,
            SKYBOX_CHECKOUT_API: SKYBOX_CHECKOUT_API + '/v2/',
            SKYBOX_CHECKOUT_AUHT: SKYBOX_CHECKOUT_API + "/v2/authenticate",
            SKYBOX_CHECKOUT_AUHT_CART: SKYBOX_CHECKOUT_API + "/v2/authenticate/cart",
            SKYBOX_CHECKOUT_CART: SKYBOX_CHECKOUT_API + "/v2/cart",
            SKYBOX_CHECKOUT_MULTICALCULATE: SKYBOX_CHECKOUT_API + "/v2/multicalculate",
            SKYBOX_CHECKOUT_API_BASE: SKYBOX_CHECKOUT_API,
            URL_CONTENT: SKYBOX_CHECKOUT_URL_CONTENT,
            URL_TIENDAWEB: "WebForms/Checkout/APICheckout.aspx?"
        };
    };
    return SdkConfig;
}());
exports.SdkConfig = SdkConfig;
var Sdk = /** @class */ (function (_super) {
    __extends(Sdk, _super);
    /** inicializa la variable de `isAuthenticated` y si en caso la session existe setea las demas varaibles */
    function Sdk(settings) {
        var _this = _super.call(this, settings) || this;
        /** Variable que se disparara cada vez que la authentication ha sido seteada o actualizada */
        _this.$authenticate = new rxjs_2.Subject();
        _this.common = new utils_1.SdkUtils();
        _this.sdkService = new sdk_1.SdkService(_this.settings, _this.apiConfig);
        /** Valido si la autenticación esta guardado en el sessionStorage */
        _this.isAuthenticated = GV.store.get(const_1.STORAGE_KEY.AUTH_STORE) ? true : false;
        _this.addElementStyleToRemovePriceStyle();
        /** Método que detectara los http requests */
        _this.common.detectHttpRequests();
        return _this;
    }
    /** Método que inicializa la aplicación */
    Sdk.prototype.init = function () {
        var _this = this;
        /** functión que inicializa la subscripción de observables */
        this.subscribes();
        this.onready(function () {
            if (GV.store.get(const_1.STORAGE_KEY.AUTH_STORE)) {
                _this.authData = GV.store.get(const_1.STORAGE_KEY.AUTH_STORE);
                GV.$authData.next(_this.authData);
                if (_this.isAuthenticated)
                    _this.$authenticate.next('logged');
            }
            if (GV.store.get(const_1.STORAGE_KEY.CART_PROD_ARR)) {
                _this.cartData = GV.store.get(const_1.STORAGE_KEY.CART_PROD_ARR);
                GV.$cartData.next(_this.cartData);
            }
            _this.setLocation();
            _this.callCartJs();
        });
    };
    Sdk.prototype.subscribes = function () {
        var _this = this;
        GV.$authData.subscribe(function (authData) {
            _this.authData = authData;
            // this.setSessionStorage();
            // this.authStoreValidateOnCompleteExpiration();
            /** Seteo el token y el merchant en los headers para todos los requests futuros */
            _this.setAuthHeaders();
            _this.$authenticate.next('logged!');
        });
        GV.$cartData.subscribe(function (cartData) {
            _this.cartData = cartData;
            GV.store.set(const_1.STORAGE_KEY.CART_PROD_ARR, _this.cartData);
            _this.setSessionStorage();
        });
        /** subscribe when cartJs is emitted */
        GV.$cartDispared.subscribe(function (response) {
            _this.shopifyCart = response;
            _this.setSessionStorage();
            if (_this.cartData) {
                _this.instanceCartSynchronize();
            }
        });
        /** @ToDo se podria mejorar, para que ni bien empiece el cargado de pagina, no haga un cambio brusco.*/
        this.$authenticate.subscribe(function () {
            if (_this.settings.INTEGRATION === 1) {
                if (_this.authData.Data.LocationAllow === 1) {
                    _this.editPriceStyle(true);
                }
                else {
                    _this.editPriceStyle(false);
                }
            }
        });
    };
    Sdk.prototype.instanceCartSynchronize = function () {
        if (!this.cartSynchronize) {
            this.cartSynchronize = new synchronize_1.CartSynchronize(this.shopifyCart, this.sdkService);
        }
        this.cartSynchronize.shopifyCart = this.shopifyCart;
        this.cartSynchronize.synchronize();
    };
    /** artificio para iniciar la aplicación cuando el documento (DOM) este listo */
    Sdk.prototype.onready = function (f) {
        var _this = this;
        /in/.test(document.readyState) ? setTimeout(function () { return _this.onready(function () { return f(); }); }, 9) : f();
    };
    /**
     * Valido si la autenticación ya esta guardado en el sessionStorage,
     * segun si es verdadero o falso, llamo al carrito, o obtengo la IP y vuelvo a autenticarme
     * */
    Sdk.prototype.setLocation = function () {
        if (this.isAuthenticated) {
            this.setAuthHeaders();
            this.getCartAndValidCountryChange(this.authData.Data.Cart.Id);
        }
        else {
            this.getIp();
        }
    };
    /**
     * Obtengo los datos del navegador mediante un servicio,
     * una vez que los tengo, me autentico por otro servicio
     * */
    Sdk.prototype.getIp = function () {
        var _this = this;
        this.sdkService.getIP().subscribe(function (response) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.ipData = response;
                        /** ya estoy autenticado, entonces seteo los headers, y obtengo el carrito */
                        if (this.isAuthenticated)
                            this.ipData.CartId = this.cartData.Data.Cart.Id;
                        return [4 /*yield*/, this.authenticate(this.ipData)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); }, function (error) { return rxjs_1.throwError(error); });
    };
    /**
     * Método para autenticar, una vez autenticado, seteo el header
     * para todos los futuros requests que se haran.
     * @param {IIPData} ipdata variable necesaria para poder autenticarse
     * */
    Sdk.prototype.authenticate = function (ipdata) {
        var _this = this;
        this.sdkService.authenticate(ipdata).subscribe(function (response) {
            _this.authData = response;
            _this.setAuthStorage();
            _this.setSessionStorage();
            GV.$authData.next(_this.authData);
            /** Ya que se hizo un `next` a un observable, le damos un setTimeOut de 1 milisegundo para esperar el cambio */
            setTimeout(function () {
                if (_this.isAuthenticated)
                    _this.initChangeCountry();
                else
                    _this.getCartAndValidCountryChange(_this.authData.Data.Cart.Id);
            }, 1);
        }, function (error) { return rxjs_1.throwError(error); });
    };
    Sdk.prototype.setAuthStorage = function () {
        GV.store.set(const_1.STORAGE_KEY.AUTH_STORE, this.authData, 270000);
        GV.store.set(const_1.STORAGE_KEY.SBC_CART_ID, this.authData.Data.Cart.Id.trim());
        this.authStoreValidateOnCompleteExpiration();
    };
    /**
     * Método que sirve para setear los headers de autenticación en las futuras llamadas a servicios
     * */
    Sdk.prototype.setAuthHeaders = function () {
        /** @ToDo hay que definir de donde se saca el MerchantCode, del servicio o de la variable `settings`*/
        this.sdkService.setAuthHeader(this.authData.Data.Token, this.settings.MERCHANTCODE);
    };
    /**
     * Mediante un servicio, obtengo el carrito
     * @param {string} cartId ID del carrito
     * */
    Sdk.prototype.getCartAndValidCountryChange = function (cartId) {
        var _this = this;
        this.sdkService.getCart(cartId).subscribe(function (response) {
            _this.cartData = response;
            GV.$cartData.next(response);
            _this.setSessionStorage();
            /** Ya que se hizo un `next` a un observable, le damos un setTimeOut de 1 milisegundo para esperar el cambio */
            setTimeout(function () {
                var countryName = GV.store.get(const_1.STORAGE_KEY.LAST_COUNTRY);
                if (countryName && countryName != '' && countryName != _this.cartData.Data.Country.Name.toUpperCase().trim()) {
                    _this.getIp();
                }
                else {
                    _this.initChangeCountry();
                }
                GV.store.set(const_1.STORAGE_KEY.LAST_COUNTRY, _this.cartData.Data.Country.Name.trim().toUpperCase());
            }, 1);
        }, function (error) { return rxjs_1.throwError(error); });
    };
    /** setea algunas variables de sesión */
    Sdk.prototype.setSessionStorage = function () {
        if (this.cartData)
            this.authData.Data.CART_SKY = {
                Cart: this.cartData.Data.Cart,
                Country: this.cartData.Data.Country
            };
        GV.store.set(const_1.STORAGE_KEY.AUTH_STORE, this.authData);
    };
    Sdk.prototype.authStoreValidateOnCompleteExpiration = function () {
        var _this = this;
        var authObservable = GV.store.getExpirationIntervalFromKey(const_1.STORAGE_KEY.AUTH_STORE);
        authObservable.subscribe(function (v) {
            console.log(v);
        }, function (error) {
        }, function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: 
                    // this.isAuthenticated = false;
                    return [4 /*yield*/, this.getIp()];
                    case 1:
                        // this.isAuthenticated = false;
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
    };
    /** Método que inicializa el cambio de pais */
    Sdk.prototype.initChangeCountry = function () {
        if (this.settings.INTEGRATION === 1) {
            var changeCountry = new change_country_1.ChangeCountry(this.authData, this.cartData, this.settings, this.apiConfig);
            changeCountry.render();
            global_variables_1.$initChangeCountry.next(changeCountry);
            this.callMulticalculate();
        }
    };
    Sdk.prototype.callCartJs = function () {
        var _this = this;
        if (window.location.href.indexOf('/cart') === -1 && window.location.href.indexOf(this.settings.SUCCESSFUL_PAGE) === -1) {
            setTimeout(function () { return _this.sdkService.getCartJs().subscribe(); }, 1000);
        }
    };
    /** @ToDo no olvidar que esta función  hace una validación de "variantes" */
    Sdk.prototype.callMulticalculate = function () {
        var _this = this;
        this.sdkMulticalculate = new multicalculate_1.SdkMulticalculate(this.settings, this.sdkService);
        if (window.location.href.indexOf('/cart') === -1 && window.location.href.indexOf(this.settings.SUCCESSFUL_PAGE) === -1) {
            setTimeout(function () {
                var currentUrl = window.location.href;
                if (currentUrl.match(/[?]variant=/gi)) {
                    var currentCode = currentUrl.split("?variant=")[1];
                    // searchVariant(currentCode, false, null, __cnStore.SKBX_LOADER_NAME);
                }
                else {
                    _this.sdkMulticalculate.init();
                    global_variables_1.$initMulticalculate.next('initialized');
                }
            }, 500);
        }
    };
    Sdk.prototype.addElementStyleToRemovePriceStyle = function () {
        this.style = document.createElement('style');
        this.style.type = "text/css";
        var head = document.head || document.getElementsByTagName('head')[0];
        head.appendChild(this.style);
        if (this.isAuthenticated && this.settings.INTEGRATION === 1) {
            if (this.authData.Data.LocationAllow === 1) {
                this.editPriceStyle(true);
            }
            else {
                this.editPriceStyle(false);
            }
        }
    };
    Sdk.prototype.editPriceStyle = function (visible) {
        var skbx_price = '.skbx-price';
        var skbx_pricestore = '.skbx-price-store';
        var style = " " + skbx_price + " { display:none } " + skbx_pricestore + " { display:block } ";
        if (visible) {
            style = " " + skbx_price + " { display:block } " + skbx_pricestore + " { display:none } ";
        }
        this.style.innerHTML = style;
    };
    return Sdk;
}(SdkConfig));
exports.Sdk = Sdk;

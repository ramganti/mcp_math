"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
var const_1 = require("./const");
var utils_1 = require("../common/utils/utils");
var GV = require("../common/global_variables");
var operators_1 = require("rxjs/operators");
var utils_2 = require("./utils");
var global_variables_1 = require("../common/global_variables");
var global_variables_2 = require("../common/global_variables");
var CartSynchronize = /** @class */ (function () {
    function CartSynchronize(shopifyCart, sdkService) {
        var _this = this;
        this.utils = new utils_2.SdkUtils();
        this.loaderModal = new global_variables_1.tingle.modal({
            footer: false,
            stickyFooter: false,
            closeMethods: []
        });
        this.sa = global_variables_2.SynchronizeActions;
        this.setContentModal();
        this.sdkService = sdkService;
        this.shopifyCart = shopifyCart;
        this.cart = GV.store.get(const_1.STORAGE_KEY.CART_PROD_ARR);
        this.authData = GV.store.get(const_1.STORAGE_KEY.AUTH_STORE);
        GV.$cartData.subscribe(function (cart) {
            _this.cart = cart;
        });
        GV.$authData.subscribe(function (authData) {
            _this.authData = authData;
        });
    }
    CartSynchronize.prototype.updateCart = function (cart) {
        var _this = this;
        this.cart = cart;
        if (const_1.SDK_SETTINGS.INTEGRATION === 1) {
            this.utils.updateShoppingCart(this.cart);
            this.sdkService.getConcepts(this.cart.Data.Cart.Id).subscribe(function (conceptos) {
                var conceptHTML = _this.utils.conceptsTableCart(conceptos);
                _this.setHtmlConceptDetail(conceptHTML);
            });
        }
        else {
            this.utils.initBtnSkyCheckout(this.authData);
        }
    };
    CartSynchronize.prototype.setContentModal = function () {
        var rutaLoaderGif = "https://s3.amazonaws.com/sky-sbc-images/WebApp/SBC/Images/loaders/loaderGris.gif";
        if (const_1.SDK_SETTINGS.SKBX_LOADER_NAME) {
            rutaLoaderGif = "https://s3.amazonaws.com/sky-sbc-images/WebApp/SBC/Images/loaders/" + const_1.SDK_SETTINGS.SKBX_LOADER_NAME;
        }
        this.loaderModal.setContent("<center> \n            <span class=\"restricted-msg\"> Wait a moment please </span>\n            <div style=\"padding-top: 10px;\">\n            <img src=\"" + rutaLoaderGif + "\"/>\n            </div>\n            </center>");
    };
    CartSynchronize.prototype.synchronize = function () {
        global_variables_2.$initSynchronize.next('Se inicio sincronización');
        var auth = GV.store.get(const_1.STORAGE_KEY.AUTH_STORE);
        var currentCountry = auth.Data.CART_SKY.Country.Name.trim().toUpperCase();
        var itemsSky = this.cart.Data.Cart.Items;
        var itemsStore = this.shopifyCart.items;
        /** valido si es que hay items en el cart de shopify */
        if (itemsStore && itemsStore.length) {
            /** valido si el pais anterior es igual al actual */
            if (currentCountry === GV.LAST_COUNTRY) {
                /** valido si existen items en el carrito de Sky */
                if (itemsSky && itemsSky.length) {
                    /** creo unos atributos mas al carrito de shopify */
                    itemsStore = this.editShopifyItemsData(itemsStore);
                    /** aqui realizare las acciones de editar, remover, agregar, segun sea el caso */
                    this.detectChangesStoreItemsAndSkyItems(itemsSky, itemsStore);
                }
                else {
                    /** si en caso no hay items en el carrito de Sky, pero si hay en el de Shopify */
                    this.addProduct(itemsStore);
                }
            }
            else {
                /** si en caso el pais anterior y el actual son diferentes, se cargara un modal de espera */
                this.loaderModal.open();
                this.detectChangesStoreItemsAndSkyItems(itemsSky, itemsStore, currentCountry);
            }
        }
        else {
            /** @ToDo preguntar si esto va asi, o deberia cambiarse */
            if (itemsSky.length) {
                this.removeCart();
            }
            else {
                GV.store.remove(const_1.STORAGE_KEY.CART_PROD_ARR);
            }
        }
    };
    /**
     * Método que detectara los cambios que ha habido cuando se agrega, edita, elimina algun producto del carrito de la tienda.
     * @param {ICardDetailItem} itemsSky productos desde SkyCheckout
     * @param {IShopifyCartItem} itemsSky productos desde la tienda actual (Shopify, Magento, BigCommerce, etc)
     * */
    CartSynchronize.prototype.detectChangesStoreItemsAndSkyItems = function (itemsSky, itemsStore, currentCountry) {
        var _this = this;
        var countChanges = 0;
        /** verifico si entre el carrito de shopify y de SKY hay diferencias */
        var changes = utils_1.arrayObjectDiff(itemsSky, itemsStore, 'Code');
        /** almaceno los productos restringidos si en caso hubiera */
        var restrictedProducts = itemsSky.filter(function (p) { return p.IsRestricted; });
        /** si esto es verdadero, remuevo del carrito los productos restringidos */
        if (restrictedProducts.length) {
            countChanges++;
            if (currentCountry) {
                this.deleteProductsFromCart(restrictedProducts, itemsStore, currentCountry);
            }
            restrictedProducts.forEach(function (v) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.removeProduct("" + v.Id, true)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            }); }); });
        }
        /** si esto es verdadero, se agregara productos al carrito */
        if (changes.added.length) {
            countChanges++;
            this.addProduct(changes.added);
        }
        /** si esto es verdadero, removera uno o mas productos del carrito */
        if (changes.removed.length) {
            countChanges++;
            changes.removed.forEach(function (v) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.removeProduct("" + v.Id, true)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            }); }); });
        }
        /** si esto es verdadero, se evaluara si se editara el carrito o no se ha realizado cambios en este */
        if (changes.common.length) {
            var array_diff_1 = [];
            changes.common.forEach(function (v, i, array) {
                var skyItem = itemsSky.find(function (s) { return s.Code === v.Code; });
                if (skyItem && v.Quantity.toString() != skyItem.Quantity.toString()) {
                    array_diff_1.push({ Id: skyItem.Id, Quantity: v.Quantity });
                }
            });
            /** validamos si es que hay diferencias entre el carrito de shopify y SKY, si las hay, se procedera a editar el carrito */
            if (array_diff_1.length > 0) {
                countChanges++;
                var productsEdited = { 'Product': array_diff_1 };
                this.editProduct(productsEdited);
            }
        }
        /** Si no ha habido ningun cambio, pero si existen items en la tienda actual */
        if (countChanges === 0 && itemsStore.length) {
            this.updateCart(this.cart);
        }
    };
    /**
     * Este método se ejecutara cuando haya productos restringidos, esto sucede cuando se hace el cambio de pais
     * y algun producto del carrito no esta permitido por alguna razon en el pais seleccionado.
     * */
    CartSynchronize.prototype.deleteProductsFromCart = function (restricteditems, itemsStore, currentCountry) {
        var _this = this;
        restricteditems.forEach(function (v, i) { return restricteditems[i].HtmlObjectId = v.Code; });
        /** Por cada plataforma, las acciones a ejecutar son diferentes, aca se validan segun sea*/
        switch (const_1.SDK_SETTINGS.MOD_PLATAFORM) {
            case 'shopify':
                var restriction_1 = this.validateRestriction(restricteditems, itemsStore, currentCountry);
                if (Object.keys(restriction_1.objUpdate.updates).length) {
                    this.sdkService.cartShopifyDelete(restriction_1.objUpdate).subscribe(function () {
                        _this.modalProductsRestricted(restriction_1.html);
                    });
                }
                break;
            case 'bigcommerce':
                restricteditems.forEach(function (v, i) {
                    var bigCommerceObservable = _this.sdkService.cartBigCommerceDelete(_this.cart.Data.Cart.Id, "" + v.Id);
                    bigCommerceObservable.subscribe(function () {
                    });
                });
                this.modalProductsRestricted(restriction_1.html);
                break;
            case 'magento':
                var magentoBody = restricteditems.map(function (r) {
                    return { idVariant: "" + r.Id, Errors: r.Errors };
                });
                if (magentoBody.length)
                    this.sdkService.cartMagentoDelete(magentoBody)
                        .subscribe(function () { return _this.modalProductsRestricted(restriction_1.html); });
                break;
            default:
                throw new Error('Nombre de plataforma incorrecto');
        }
    };
    CartSynchronize.prototype.modalProductsRestricted = function (html) {
        var restrictedModal = new global_variables_1.tingle.modal({
            footer: true,
            stickyFooter: true,
            closeMethods: ['overlay', 'button', 'escape']
        });
        restrictedModal.setContent(html);
        restrictedModal.addFooterBtn('Close', 'tingle-btn tingle-btn--default tingle-btn--pull-right', function () {
            restrictedModal.close();
        });
        restrictedModal.open();
    };
    CartSynchronize.prototype.editShopifyItemsData = function (items) {
        items.forEach(function (v, i) {
            items[i].Code = "" + v.variant_id;
            items[i].Quantity = "" + v.quantity;
        });
        return items;
    };
    CartSynchronize.prototype.addProduct = function (productos) {
        var _this = this;
        productos = productos ? productos : this.shopifyCart.items;
        var listProducts = [];
        productos.forEach(function (v) {
            var getWeight = _this.utils.calcWeightAndUnit(v.grams);
            var _Optionals = { CustomFields: ["" + v.sku] };
            var variant_title = !v.variant_title ? '' : "-" + v.variant_title;
            if (const_1.SDK_SETTINGS.CONF.PRODUCT_TYPE_DEFAULT !== '') {
                v.product_type = const_1.SDK_SETTINGS.CONF.PRODUCT_TYPE_DEFAULT;
            }
            listProducts.push({
                Product: {
                    HtmlObjectid: "" + v.variant_id,
                    Id: "" + v.variant_id,
                    Sku: "" + v.variant_id,
                    Name: v.product_title + variant_title,
                    Category: v.product_type,
                    Price: (v.price / 100),
                    ImgUrl: v.image,
                    Language: "",
                    Weight: getWeight.weight,
                    WeightUnit: getWeight.unit,
                    VolumetricWeight: 0,
                    DefinitionOpt: "",
                    Quantity: v.quantity,
                    ProductMerchantId: ""
                }, Optionals: _Optionals
            });
        });
        var cartId = this.cart.Data.Cart.Id;
        var headerCartId = { 'X-Skybox-Cart-Id': cartId };
        var body = { ListProducts: listProducts };
        var requestObservable = this.sdkService.addProducts(cartId, body, headerCartId);
        requestObservable.pipe(operators_1.tap(function (r) { return _this.sa.$onAdd.next(r); }))
            .subscribe(function () { return _this.reloadCart(); });
    };
    /** @ToDo falta la interface de edición de productos */
    CartSynchronize.prototype.editProduct = function (editedProducts) {
        var _this = this;
        var cartId = this.cart.Data.Cart.Id;
        var headerCartId = { 'X-Skybox-Cart-Id': cartId };
        var requestObservable = this.sdkService.editProducts(cartId, editedProducts, headerCartId);
        requestObservable.pipe(operators_1.tap(function (r) { return _this.sa.$onUpdate.next(r); }))
            .subscribe(function () { return _this.reloadCart(); });
    };
    CartSynchronize.prototype.removeProduct = function (productId, promise) {
        var _this = this;
        var cartId = this.cart.Data.Cart.Id;
        var headerCartId = { 'X-Skybox-Cart-Id': cartId };
        var requestObservable = this.sdkService.removeProducts(cartId, productId, headerCartId);
        if (promise) {
            requestObservable.pipe(operators_1.take(1), operators_1.tap(function (r) { return _this.sa.$onDelete.next(r); })).toPromise()
                .then(function () { return _this.reloadCart(); });
        }
        else
            requestObservable.pipe(operators_1.tap(function (r) { return _this.sa.$onDelete.next(r); }))
                .subscribe(function () { return _this.reloadCart(); });
    };
    CartSynchronize.prototype.removeCart = function () {
        var _this = this;
        var cartId = this.cart.Data.Cart.Id;
        var requestObservable = this.sdkService.removeCart(cartId);
        requestObservable.pipe(operators_1.tap(function (r) { return _this.sa.$onRemoveCart.next(r); }))
            .subscribe(function () { return _this.reloadCart(); });
    };
    CartSynchronize.prototype.reloadCart = function () {
        var _this = this;
        if (this.loaderModal && this.loaderModal.isOpen()) {
            this.loaderModal.close();
        }
        this.sdkService.getCart(this.cart.Data.Cart.Id).subscribe(function (cart) {
            GV.$cartData.next(cart);
            _this.updateCart(cart);
        });
    };
    CartSynchronize.prototype.setHtmlConceptDetail = function (conceptHtml) {
        var _this = this;
        if ($('.international-checkout').length) {
            $('.international-checkout').html(conceptHtml);
            this.utils.hideLoaders();
            this.utils.initBtnSkyCheckout(this.authData);
        }
        else {
            var findPriceHtml_1 = setInterval(function () {
                if ($('.international-checkout').length) {
                    $('.international-checkout').html(conceptHtml);
                    _this.utils.hideLoaders();
                    _this.utils.initBtnSkyCheckout(_this.authData);
                    clearInterval(findPriceHtml_1);
                }
            }, 100);
        }
    };
    CartSynchronize.prototype.validateRestriction = function (arraySky, arrayStore, currentCountry) {
        var clonedArrStore = arrayStore, objUpdate = { updates: {} }, html = '';
        if (arraySky && arraySky.length > 0) {
            html += '<div>';
            html += '<br />';
            html += ' <p class="restricted-msg">' + 'The following products will be removed from your shopping cart, they are' + '<strong>' + ' restricted in ' + currentCountry + '</strong>';
            html += ' <table>';
            html += '   <tbody>';
            arraySky.forEach(function (item) {
                for (var i in clonedArrStore) {
                    var objStore = clonedArrStore[i], code = objStore.variant_id ? String(objStore.variant_id) : String(objStore.id);
                    if ((item.HtmlObjectId).trim() === (code).trim()) {
                        objUpdate.updates[objStore.variant_id] = 0;
                        html += '     <tr>';
                        html += '       <td>';
                        html += '         <center><img style="height: 150px;" src="' + objStore.image + '"</img>' + '</center>';
                        html += '       </td>';
                        html += '       <td>';
                        html += '         <strong> <p class="restricted-msg">' + objStore.title + '</p>' + '</strong>' + '<br />';
                        html += '       </td>';
                        html += '     </tr>';
                        break;
                    }
                }
            });
            html += '   </tbody>';
            html += ' </table>';
            html += '</div>';
        }
        return {
            objUpdate: objUpdate,
            html: Object.keys(objUpdate.updates).length > 0 ? html : ''
        };
    };
    return CartSynchronize;
}());
exports.CartSynchronize = CartSynchronize;

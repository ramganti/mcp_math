import {
    IIPData,
    IResponseAuth,
    ISdkConfig,
    ISdkSettings,
    ICart,
    IShopifyCart
} from "../common/interfaces";
import {SdkService} from "../common/services/sdk";
import {throwError} from "rxjs";
import {STORAGE_KEY} from "./const";
import {ChangeCountry} from "./change-country";
import {Subject} from 'rxjs';
import * as GV from '../common/global_variables';
import {SdkUtils} from "./utils";
import {CartSynchronize} from "./synchronize";
import {SdkMulticalculate} from "./multicalculate";
import {
    $initChangeCountry,
    $initMulticalculate
} from "../common/global_variables";

export class SdkConfig {
    settings: ISdkSettings;
    apiConfig: ISdkConfig;

    constructor(settings: ISdkSettings) {
        this.settings = settings;
        /** @ToDo consultar si esto es correcto */
        this.apiConfig = this.setConfigAPI(settings.IS_API_BETA, settings.IS_API_PREPROD);
        this.settings.URL = this.apiConfig.SKYBOX_CHECKOUT_API + 'store/' + settings.IDSTORE + '/ipdata';
        this.settings.SKYBOX_URL = this.apiConfig.SKYBOX_CHECKOUT_URL;
    }

    /** @ToDo esta funcion se podria reducir, consultarlo */
    setConfigAPI(isBeta: boolean, isPreProd: boolean): ISdkConfig {
        var SKYBOX_CHECKOUT_URL = "https://www.skyboxcheckout.com/";
        var SKYBOX_CHECKOUT_API = "https://api.skyboxcheckout.com";
        var SKYBOX_CHECKOUT_URL_CONTENT = "https://api.skyboxcheckout.com";

        if (isPreProd) {
            SKYBOX_CHECKOUT_URL = "https://www.skyboxcheckout.com/PreApp/";
            SKYBOX_CHECKOUT_API = "https://www.skyboxcheckout.com/PreProdApiV2";
            SKYBOX_CHECKOUT_URL_CONTENT = "https://beta.skyboxcheckout.com/PreProdApiV2";
        }
        else if (isBeta) {
            SKYBOX_CHECKOUT_URL = "https://beta.skyboxcheckout.com/BetaApp/";
            SKYBOX_CHECKOUT_API = "https://www.skyboxcheckout.com/BetaApiV2";
            SKYBOX_CHECKOUT_URL_CONTENT = "https://beta.skyboxcheckout.com/BetaApiV2";
        }

        return {
            SKYBOX_CHECKOUT_URL: SKYBOX_CHECKOUT_URL,
            SKYBOX_CHECKOUT_API: SKYBOX_CHECKOUT_API + '/v2/',
            SKYBOX_CHECKOUT_AUHT: SKYBOX_CHECKOUT_API + "/v2/authenticate",
            SKYBOX_CHECKOUT_AUHT_CART: SKYBOX_CHECKOUT_API + "/v2/authenticate/cart",
            SKYBOX_CHECKOUT_CART: SKYBOX_CHECKOUT_API + "/v2/cart",
            SKYBOX_CHECKOUT_MULTICALCULATE: SKYBOX_CHECKOUT_API + "/v2/multicalculate",
            SKYBOX_CHECKOUT_API_BASE: SKYBOX_CHECKOUT_API,

            URL_CONTENT: SKYBOX_CHECKOUT_URL_CONTENT,
            URL_TIENDAWEB: "WebForms/Checkout/APICheckout.aspx?",
        }
    }
}

export class Sdk extends SdkConfig {
    common: SdkUtils;
    cartSynchronize: CartSynchronize;
    sdkMulticalculate: SdkMulticalculate;
    /** variables que van a ser instanciadas*/
    sdkService: SdkService;
    /** variables que se usaran en todo el ciclo de vida de la clase */
    authData: IResponseAuth;

    /** variable que almacena la información del IP */
    ipData: IIPData;

    /** variable que almacena la información del carrito */
    cartData: ICart;

    /** Variable para saber si ya esta autenticado o no */
    isAuthenticated: boolean;

    /** Variable que se disparara cada vez que la authentication ha sido seteada o actualizada */
    $authenticate = new Subject();

    shopifyCart: IShopifyCart;

    /** inicializa la variable de `isAuthenticated` y si en caso la session existe setea las demas varaibles */
    constructor(settings: ISdkSettings) {
        super(settings);
        this.common = new SdkUtils();
        this.sdkService = new SdkService(this.settings, this.apiConfig);
        /** Valido si la autenticación esta guardado en el sessionStorage */
        this.isAuthenticated = GV.store.get(STORAGE_KEY.AUTH_STORE) ? true : false;
        this.addElementStyleToRemovePriceStyle();
        /** Método que detectara los http requests */
        this.common.detectHttpRequests();
    }

    private style: any;

    /** Método que inicializa la aplicación */
    init() {
        /** functión que inicializa la subscripción de observables */
        this.subscribes();
        this.onready(() => {
            if (GV.store.get(STORAGE_KEY.AUTH_STORE)) {
                this.authData = GV.store.get(STORAGE_KEY.AUTH_STORE) as IResponseAuth;
                GV.$authData.next(this.authData);
                if (this.isAuthenticated) this.$authenticate.next('logged');
            }
            if (GV.store.get(STORAGE_KEY.CART_PROD_ARR)) {
                this.cartData = GV.store.get(STORAGE_KEY.CART_PROD_ARR) as ICart;
                GV.$cartData.next(this.cartData);
            }
            this.setLocation();
            this.callCartJs();
        });
    }

    subscribes() {
        GV.$authData.subscribe((authData) => {
            this.authData = authData;
            // this.setSessionStorage();
            // this.authStoreValidateOnCompleteExpiration();
            /** Seteo el token y el merchant en los headers para todos los requests futuros */
            this.setAuthHeaders();
            this.$authenticate.next('logged!');
        });

        GV.$cartData.subscribe((cartData) => {
            this.cartData = cartData;
            GV.store.set(STORAGE_KEY.CART_PROD_ARR, this.cartData);
            this.setSessionStorage();
        });

        /** subscribe when cartJs is emitted */
        GV.$cartDispared.subscribe((response: IShopifyCart) => {
            this.shopifyCart = response;
            this.setSessionStorage();
            if (this.cartData) {
                this.instanceCartSynchronize();
            }
        });

        /** @ToDo se podria mejorar, para que ni bien empiece el cargado de pagina, no haga un cambio brusco.*/
        this.$authenticate.subscribe(() => {
            if (this.settings.INTEGRATION === 1) {
                if (this.authData.Data.LocationAllow === 1) {
                    this.editPriceStyle(true);
                } else {
                    this.editPriceStyle(false);
                }
            }
        });
    }

    instanceCartSynchronize() {
        if (!this.cartSynchronize) {
            this.cartSynchronize = new CartSynchronize(this.shopifyCart, this.sdkService);
        }
        this.cartSynchronize.shopifyCart = this.shopifyCart;
        this.cartSynchronize.synchronize();
    }

    /** artificio para iniciar la aplicación cuando el documento (DOM) este listo */
    onready(f: any) {
        /in/.test(document.readyState) ? setTimeout(() => this.onready(() => f()), 9) : f()
    }

    /**
     * Valido si la autenticación ya esta guardado en el sessionStorage,
     * segun si es verdadero o falso, llamo al carrito, o obtengo la IP y vuelvo a autenticarme
     * */
    setLocation() {
        if (this.isAuthenticated) {
            this.setAuthHeaders();
            this.getCartAndValidCountryChange(this.authData.Data.Cart.Id);
        } else {
            this.getIp();
        }
    }

    /**
     * Obtengo los datos del navegador mediante un servicio,
     * una vez que los tengo, me autentico por otro servicio
     * */
    getIp() {
        this.sdkService.getIP().subscribe(async response => {
            this.ipData = response;
            /** ya estoy autenticado, entonces seteo los headers, y obtengo el carrito */
            if (this.isAuthenticated) this.ipData.CartId = this.cartData.Data.Cart.Id;
            await this.authenticate(this.ipData);
        }, error => throwError(error));
    }

    /**
     * Método para autenticar, una vez autenticado, seteo el header
     * para todos los futuros requests que se haran.
     * @param {IIPData} ipdata variable necesaria para poder autenticarse
     * */
    authenticate(ipdata: IIPData) {
        this.sdkService.authenticate(ipdata).subscribe(response => {
            this.authData = response;
            this.setAuthStorage();
            this.setSessionStorage();
            GV.$authData.next(this.authData);
            /** Ya que se hizo un `next` a un observable, le damos un setTimeOut de 1 milisegundo para esperar el cambio */
            setTimeout(() => {
                if (this.isAuthenticated) this.initChangeCountry();
                else this.getCartAndValidCountryChange(this.authData.Data.Cart.Id);
            }, 1);
        }, error => throwError(error));
    }

    setAuthStorage() {
        GV.store.set(STORAGE_KEY.AUTH_STORE, this.authData, 270000);
        GV.store.set(STORAGE_KEY.SBC_CART_ID, this.authData.Data.Cart.Id.trim());
        this.authStoreValidateOnCompleteExpiration();
    }

    /**
     * Método que sirve para setear los headers de autenticación en las futuras llamadas a servicios
     * */
    setAuthHeaders() {
        /** @ToDo hay que definir de donde se saca el MerchantCode, del servicio o de la variable `settings`*/
        this.sdkService.setAuthHeader(this.authData.Data.Token, this.settings.MERCHANTCODE);
    }

    /**
     * Mediante un servicio, obtengo el carrito
     * @param {string} cartId ID del carrito
     * */
    getCartAndValidCountryChange(cartId: string) {
        this.sdkService.getCart(cartId).subscribe((response) => {
            this.cartData = response;
            GV.$cartData.next(response);
            this.setSessionStorage();
            /** Ya que se hizo un `next` a un observable, le damos un setTimeOut de 1 milisegundo para esperar el cambio */
            setTimeout(() => {
                const countryName = GV.store.get(STORAGE_KEY.LAST_COUNTRY);
                if (countryName && countryName != '' && countryName != this.cartData.Data.Country.Name.toUpperCase().trim()) {
                    this.getIp();
                } else {
                    this.initChangeCountry();
                }
                GV.store.set(STORAGE_KEY.LAST_COUNTRY, this.cartData.Data.Country.Name.trim().toUpperCase());
            }, 1)
        }, error => throwError(error));
    }

    /** setea algunas variables de sesión */
    setSessionStorage() {
        if (this.cartData) this.authData.Data.CART_SKY = {
            Cart: this.cartData.Data.Cart,
            Country: this.cartData.Data.Country
        };
        GV.store.set(STORAGE_KEY.AUTH_STORE, this.authData);
    }

    authStoreValidateOnCompleteExpiration() {
        const authObservable = GV.store.getExpirationIntervalFromKey(STORAGE_KEY.AUTH_STORE);
        authObservable.subscribe((v) => {
            console.log(v)
        }, error => {
        }, async () => {
            // this.isAuthenticated = false;
            await this.getIp();
        });
    }

    /** Método que inicializa el cambio de pais */
    initChangeCountry() {
        if (this.settings.INTEGRATION === 1) {
            const changeCountry = new ChangeCountry(this.authData, this.cartData, this.settings, this.apiConfig);
            changeCountry.render();
            $initChangeCountry.next(changeCountry);
            this.callMulticalculate();
        }
    }

    callCartJs() {
        if (window.location.href.indexOf('/cart') === -1 && window.location.href.indexOf(this.settings.SUCCESSFUL_PAGE) === -1) {
            setTimeout(() => this.sdkService.getCartJs().subscribe(), 1000);
        }
    }

    /** @ToDo no olvidar que esta función  hace una validación de "variantes" */
    callMulticalculate() {
        this.sdkMulticalculate = new SdkMulticalculate(this.settings, this.sdkService);
        if (window.location.href.indexOf('/cart') === -1 && window.location.href.indexOf(this.settings.SUCCESSFUL_PAGE) === -1) {
            setTimeout(() => {
                var currentUrl = window.location.href;
                if (currentUrl.match(/[?]variant=/gi)) {
                    var currentCode = currentUrl.split("?variant=")[1];
                    // searchVariant(currentCode, false, null, __cnStore.SKBX_LOADER_NAME);
                } else {
                    this.sdkMulticalculate.init();
                    $initMulticalculate.next('initialized');
                }
            }, 500);
        }
    }

    private addElementStyleToRemovePriceStyle() {
        this.style = document.createElement('style') as any;
        this.style.type = "text/css";
        let head = document.head || document.getElementsByTagName('head')[0];
        head.appendChild(this.style);

        if (this.isAuthenticated && this.settings.INTEGRATION === 1) {
            if (this.authData.Data.LocationAllow === 1) {
                this.editPriceStyle(true);
            } else {
                this.editPriceStyle(false);
            }
        }
    }

    editPriceStyle(visible: boolean): void {
        const skbx_price = '.skbx-price';
        const skbx_pricestore = '.skbx-price-store';
        let style = ` ${skbx_price} { display:none } ${skbx_pricestore} { display:block } `;
        if (visible) {
            style = ` ${skbx_price} { display:block } ${skbx_pricestore} { display:none } `;
        }
        this.style.innerHTML = style;
    }
}



